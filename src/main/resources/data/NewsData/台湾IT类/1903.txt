PHP是現在網站中最爲常用的後端語言之一，是一種類型系統動態、弱類型的面向對象式編程語言。可以嵌入HTML文本中，是目前最流行的web後端語言之一，並且可以和WebServer如apache和nginx方便的融合。目前，已經佔據了服務端市場的極大佔有量。

但是，弱類型，一些方便的特性由於新手程序員的不當使用，造成了一些漏洞，這篇文章就來介紹一下一些滲透中可以用的特性。

先來複習一下基本的語法：php中有如下兩種比較符號：兩個等號和三個等號（這一點和Java）有些類似

明確的看到，兩個等於號的等於會在比較的時候進行類型轉換的比較。

明確的寫出瞭如果一個數值和一個字符串比較，那麼會將字符串轉換爲數值（而不是相反，將數值轉化爲字符串）

當一個字符串被當作一個數值來取值，其結果和類型如下：如果該字符串沒有包含‘.’，’e’或‘E’並且其數字值在整型的範圍之內（由PHP_INT_MAX所定義），該字符串將被當成integer來取值。其它所有情況下都被作爲float來取值。該字符串的開始部分決定了它的值。如果該字符串以合法的數值開始，則使用該數值。否則其值爲0（零）。合法數值由可選的正負號，後面跟着一個或多個數字（可能有小數點），再跟着可選的指數部分。指數部分由‘e’或‘E’後面跟着一個或多個數字構成。

這是官方手冊上面的幾個例子

我們大概可以總結出如下的規則：當一個字符串被轉換爲數值時

如果一個字符串爲「合法數字+e+合法數字」類型，將會解釋爲科學計數法的浮點數　　如果一個字符串爲「合法數字+不可解釋爲合法數字的字符串」類型，將會被轉換爲該合法數字的值，後面的字符串將會被丟棄　　如果一個字符串爲「不可解釋爲合法數字的字符串+任意」類型，則被轉換爲0！爲0…爲0

當然，上面的那些等式對於===都是false的，原本一些應該用===的地方誤用了==，導致了可以注入的地方。

這是一個ctf的題目，非常有趣，可以看到，要求給出兩字符串，一個是純數字型，一個只能出現字符，使兩個的md5哈希值相等，然而這種強碰撞在密碼學上都是無法做到的。

但是我們看到，最終比較兩者的哈希的時候，使用的是等於而不是全等於，因此可以利用一下這個漏洞

再回頭看一md5()函數

可以知道，第二個參數爲true的時候，顯示16位的結果，而爲false和沒有第二個參數時，爲32位的16進制碼（16位的結果是把32位的作爲ASCII碼進行解析）

16進制的數據中是含有e的，可以構建使得兩個數字比較的，這裏有一個現成的例子：

可以看到，這兩個字符串一個只包含數字，一個只包含字母，雖然兩個的哈希不一樣，但是都是一個形式：0e純數字這種格式的字符串在判斷相等的時候會被認爲是科學計數法的數字，先做字符串到數字的轉換。

轉換後都成爲了0的好多好多次方，都是0，相等。（大家可以自己嘗試一下）因此

用===可以避免這一漏洞。

這次這個例子是傳入一個JSON的數據，JSON在RESTful的網站中是很常用的一種數據傳輸的格式。這個表單會把一個name爲key的input的數據作爲json傳到服務端

我們該如何破解？想」a」==0這個漏洞，之用我們使$json->key是一個數字類型的變量就可以，怎麼做到呢？

php的json_decode()函數會根據json數據中的數據類型來將其轉換爲php中的相應類型的數據，也就是說，如果我們在json中傳一個string類型，那麼該變量就是string，如果傳入的是number，則該變量爲number。因此，我們如果傳入一個數字，就可以使之相等。網頁中的表單可能限制了所有的輸入都是string，即使輸入數字，傳入的東西也是

這是一個字符串0，我們需要讓他爲數字類型，用burp攔截，把兩個雙引號去掉，變成這樣：

值得討論的一點是，在這種方法的漏洞利用中，很難在直接表單類型的POST的數據中使用，這是爲什麼呢，這個和HTTP協議有關。首先，我們看一下，在POST給服務器的數據中，有幾種類型，也就是HTTPheader中的Content-Type:

第一個application/x-www-form-urlencoded，是一般表單形式提交的content-type第二個，是包含文件的表單。第三，四個，分別是json和xml，一般是js當中上傳的.

但是因爲在直接的POST的payload當中是無法區分字符串和數字的，因爲在其中並沒有引號出現，舉一個抓包的例子

可以看到，payload是放在http包的最後面的，而且都是以沒有引號的形式傳遞的，並沒有辦法區分到底是字符串還是數字。因此，PHP將POST的數據全部保存爲字符串形式，也就沒有辦法注入數字類型的數據了而JSON則不一樣，JSON本身是一個完整的字符串，經過解析之後可能有字符串，數字，布爾等多種類型。

注：這一個漏洞適用與5.3之前版本的php

我們首先看一下這個函數,這個函數是用於比較字符串的函數

可知，傳入的期望類型是字符串類型的數據，但是如果我們傳入非字符串類型的數據的時候，這個函數將會有怎麼樣的行爲呢？實際上，當這個函數接受到了不符合的類型，這個函數將發生錯誤，但是在5.3之前的php中，顯示了報錯的警告信息後，將return0!!!!也就是雖然報了錯，但卻判定其相等了。

這對於使用這個函數來做選擇語句中的判斷的代碼來說簡直是一個致命的漏洞，當然，php官方在後面的版本中修復了這個漏洞，使得報錯的時候函數不返回任何值。但是我們仍然可以使用這個漏洞對使用老版本php的網站進行滲透測試。看一段示例代碼：

對於這段代碼，我們能用什麼辦法繞過驗證呢，只要我們$_POST['password']是一個數組或者一個object即可，但是上一個問題的時候說到過，只能上傳字符串類型，那我們又該如何做呢。

其實php爲了可以上傳一個數組，會把結尾帶一對中括號的變量，例如xxx[]的name（就是$_POST中的key），當作一個名字爲xxx的數組構造類似如下的request

這一類型的漏洞的特點主要就是利用PHP中的類型特性來繞過驗證。由於==和===有着明顯的區分，因此，估計短期內PHP的作者並不會調整對於這兩個符號的策略。

而對於開發市場而言，隨着培訓機構的增多，後端程序員尤其是php後端程序員的門檻越來越低，其水平必定也是良莠不齊，這些二把刀程序員可能帶來更多的此類對於特性的不當使用導致的漏洞，因此這類漏洞仍然是非常具有利用價值的。

記住保證安全的幾句箴言：任何用戶輸入都是不可信的！對於web應用來說，前端（瀏覽器端）的安全限制只能起到防止一般用戶的誤輸入行爲，完全不可能對於黑帽子的行爲有任何的防禦作用

而對於滲透測試人員，在代碼審計的過程中，對於有==,strcmp的比較也應極爲敏感。在黑盒滲透的時候也可以對於代碼進行猜測，結合信息蒐集過程中的一些版本特性，利用這些漏洞來繞過驗證。