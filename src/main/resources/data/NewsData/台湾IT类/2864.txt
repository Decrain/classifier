AlanKay是當今世界計算機領域最重要的人物之一，他因面向對象編程方面的貢獻和設計Smalltalk語言獲得了2003年圖靈獎。同時，他也是個人計算機（PC），圖形用戶界面（GUI）的先驅。今天我們使用的C/C++或Java語言都或多或少從Smalltalk汲取過養分。

他所研究的領域遠超計算機，總能從更高層次看問題，他的想法又總是很宏大，也許你一開始並不理解他在說什麼，但回頭看總會有新收穫，他的每篇文章和每個演講都令人深受啓發。

他講話風趣且深刻，似乎隨口說的一句話就能放進名言庫裏，你肯定聽過這句話：「預測未來的最好方法就是創造未來——Thebestwaytopredictfutureistoinventit」。

關於「對象」（object）的理解，我經歷了幾個不同階段。

第一階段是50年前，在ARPA研究生院的開始幾周，我的幾種專業背景，數學、分子生物學、系統和程序設計等，與Sketchpad、Simula和ARPAnet這些東西產生了碰撞。這使我觀察到，既然一臺計算機可以分解成多臺虛擬計算機，相互間持續通信，於是你便可以：

我喜歡這些。分時運行的「進程」已是這種虛擬機的體現，但因爲開銷太大還缺少實際的通用性（那就尋找方法消除這些開銷……）。

儘管可以爲任何事物（包括數據結構）建模，對我來說這還遠遠不夠。真正了不起的是爲極端的可伸縮性需求提供鬆耦合的封裝和消息機制（以一種類似生物和生態系統的方式）。

第二個階段包括在「Lisp世界」中摻入Lisp本身，McCarthy關於機器人和時態邏輯的思想，在ARPA（尤其是在MIT）進行的AI工作，以及CarlHewitt的PLANNER語言。有一種思想：對象可以像服務器一樣，且可以是面向目標的，使用PLANNER類型的目標作爲接口語言。

第三階段是Parc的一系列Smalltalks，試圖在Parc的Alto系統（128K內存，一半用於顯示設備）所能實現的和未來必然需要的功能之間尋找一種實用的平衡。這項工作是與DanIngalls和組裏其他一些天才的同事合作完成的。理想主義的小宇宙一直讓我不爽，但從實用角度結果不錯。

第四階段（也是在Parc）是重新深入探討時態邏輯和「世界線」（world-line）思想（後面細說）。

第五階段是再次嚴肅地思考可伸縮性並重新審視「協作語言」（比如Gelernter的Linda），將它們看作以通用的發佈和描述方式進行描述匹配，從而實現鬆耦合的一種方法。我仍然喜歡這種思想，並希望看它發展到對象可以真正「協商意義」的程度。

我對這一切的思考方式大部分都可追溯到上世紀50年代的JohnMcCarthy。John是一位出色的數學家和邏輯學家。他希望自己能做嚴密一致的邏輯推理——同時希望他的程序和機器人也能做到。機器人是個關鍵：因爲他想讓機器人有時在費城，有時在紐約。按常規邏輯這會有問題，然而John針對「事實」成立時能表現「時幀」（timeframe）的所有事實額外添加了一個參數，從而修正了這一問題。這就創建了一種簡單的時態邏輯，將「事實集合」顯現爲世界線的層層堆棧。

這很容易泛化爲「變量」、「數據」、「對象」……的世界線。從個體角度來看，值的「歷史」替換了「值」，從系統角度來看，整個系統被表示爲每當系統處於兩次計算之間時它所處的穩定狀態。Simula後來採用了這一思想的一個弱化但卻實用的版本。

應當提一下ChristopherStrachey（編者注：1916年－1965年，生於英國英格蘭倫敦漢普斯敦，計算機科學家。他是指稱語義最早的提出者之一，也是編程語言設計的先驅，發展了編程語言CPL）——Lisp和McCarthy的偉大粉絲，他認識到通過始終使用（來自前一時幀的）舊值來產生新值並安裝在新的時幀中，很多種編程模型都可以統一起來且更加安全。認識到這一點是因爲他首先觀察到Lisp中「尾遞歸」是多麼乾淨利落，然後又看到這樣的尾遞歸寫成某種循環的形式更易理解：循環中包含類似賦值的語句，其中右邊從時間t中取值，被賦值的變量則存在於時間t+1中（且這樣的賦值只允許一次）。這就統一了函數式編程和同時模擬時間和狀態的「類命令式」編程。

也要提一下Ashcroft和Wadge設計的Lucid語言（編者注：一種數據流語言，用於非馮模型編程），該語言擴展了Strachey的許多思想。

另外，數據庫中的「原子事務」也值得一看，思想很類似，只是粒度更粗——從來沒有破壞什麼，也不用競爭條件，新的版本以一種非破壞性的方式創建出來。其中有了版本的歷史。

「時間是個好主意」，這是關鍵的一點——我們想要它，想用安全、合理的方式處理它——而這些方式中絕大部分（如果不是全部的話）都可以是處於穩定世界線狀態序列之間的純函數式事務。

「剛剛計算來的穩定狀態」非常有用。它再也不會改變——因此它代表了系統模擬中的一個「版本」——且可以在產生下一個穩定狀態的函數式轉換中充當源數值。它還可以充當數據源，爲那一刻的世界創建視覺效果。歷史信息則可用於調試、撤消、回滾等需要。

在這種模型中，「穩定狀態之間時間並不存在」：「時鐘」只在新狀態完成時走表。就程序而言，CPU本身並不充當時鐘。對於具有內在、乾淨時間模型的確定性關係，這種思想帶來一種非常簡易的處理方式。

出於很多理由（但沒有一個好的）這種維持安全的方法在上世紀60年代輸給了在命令式編程中使用競爭條件，然後再通過可怕的、可能導致死鎖的信號量來保護它們的做法。

某些時候，任何瞭解Lisp且對對象間的消息傳遞感興趣的人都必然「運用」並注意到一種對象（一個lambda的「東西」，可以是一個閉包）可以捆綁到一組參數上（看起來有點像消息）。如果一個人知道Lisp1.5是如何基於新式的延遲綁定參數求值來實現的，理解還會更深入。這裏指的是FEXPR，而不是EXPR——未求值的表達式可作爲參數傳遞，之後再求值。這使得不太優雅的「特殊形式」四處充斥，它們本來可以寫成漂亮的惰式函數。

使用前述的時態建模，可以鬆掉「求值－應用」的耦合，通過安全的消息傳遞來獲得時間層之間的函數式關係。於是，由於我一直喜歡從系統模擬的視角看待計算，我便把「對象」和「函數」看作兩種互補的思想，它們並不衝突。

術語一旦成爲宗教或更加嚴格的選擇與風格，便會失去它們的意義。這裏說的自然是「面向對象」和「函數式編程」這兩個術語。我不會將「函數式編程」的一般概念跟任何特定語言等同起來。我堅持認爲「函數思想」是一種可靠的映射。類似的，我也不會把「面向對象」的一般概念同任何特定語言等同起來。如今這兩個術語被「殖民」了，意思也變了。

還有一個大問題是「對象」和「抽象數據類型」的混淆，以及對「數據」和「賦值語句」的固執。如果真正強化了封裝，對象就可以根據需要處理設計參數（包括保存歷史信息）。

有朋友問我現在如何理解分佈式環境中的對象和系統模擬的，是否依然認爲有可能構造一種系統，它既有互聯網那樣可以有機增長的規模，又有類似於虛擬時間的良好的、可預測的語義？

好問題。這裏面有好幾組問題及其權衡關係。二十世紀70年代DaveReed（編者注：美國計算機科學家，UDP協議設計者）最初思考的是面向整個互聯網的操作系統應具有什麼樣子。在他提出的許多有趣想法中，其中之一是通過由虛擬時間（pseudo-time）組織起來的分佈式克隆計算來處理長延時和海量潛在用戶的問題，然後慢速的互聯網僅用於輸入和偏差同步。這就是我們本世紀00年代早期在Croquet中實現的東西，那時互聯網上一次典型的、還算不錯的ping來回大約80到100毫秒。這已經好到可以無需任何服務器而創建《魔獸世界》這樣的大規模並行遊戲（甚至飛行仿真遊戲）了，只要有玩家正在用着的那些機器就夠了（分佈式）。後來的版本做得更多更全面。

插一句，去掉實時圖形和交互的Croquet便自動提供了一種分佈式的面向對象數據庫。虛擬時間是背後的大理念，保護着數據庫中的分佈式原子事務。

而且多年來人們一直在討論。它能否實現？需要在哪些領域做多少工作？等等。

我們在Parc做過的與對象有關的工作就是ARPA/Parc社區中發生的網絡思維的一部分，它最終產生了思考更高層網絡實體的傾向。「網絡層實體」的一個相當不錯的、過渡性的實現是GerryPopek在Parc花了一年時間思考「網終系統應有的樣子」之後，和他在UCLA的團隊一起完成的LOCUS系統。那是建立在異構機器類型之上的一種遷移式的負載平衡思想，與虛擬時間概念形成高度的互補。

我希望看到富有才華的團隊把第二個問題再過一篇。對可伸縮規模的適應性很難事先預測，最好實際去實現它。對於虛擬時間，如果你瞭解它卻不使用它，任何情況下我都覺得有點瘋狂，而如果不瞭解它，那就有點業餘了。在這兩者之間，則是以各種「不二法門」爲特徵的宗教（而這跟任何科學都背道而馳）。