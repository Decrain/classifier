Android開發中，我們經常用到各種開源框架，很多優秀的框架不僅提供了功能豐富的功能接口，其高超的代碼編寫和組織水平也值得我們學習。通過學習這些框架的源碼，有助於快速提高我們的編程質量。在接下來的博客中，我將對一系列優秀的開源框架源碼進行閱讀分析，目的有兩個，一是理解框架的實現機制，從源碼的角度去分析怎樣更好的使用這些框架。二是從這些優秀的源碼中學習如何組織代碼，如何實現高質量的編程。本文我們將分析Android圖片加載工具Picasso源碼。

我們從Picasso使用方式上入手，Picasso的使用通常分爲兩步，第一步初始化Picasso單例，第二步獲取Picasso單例，創建RequestCreator，加載圖片。代碼示例如下：

Picasso初始化用到了單例模式和構造者模式。關於構造者模式的講解可以查看這篇文章（http://www.jianshu.com/p/13058bc5b514），此處不再贅述。在Picasso初始化用到Picasso.Builder靜態內部類，有以下設置項：

這樣就完成了Picasso單例的初始化，並完成了一些全局的設置。接下來可以通過這個單例加載圖片並展示了。

獲取到Picasso單例對象後，調用picasso.load函數，返回一個RequestCreator對象，該對象用於構造一個具體的加載圖片請求Request。

RequestCreator採用了構造者模式，提供了一系列設置函數，可以設置本次要加載圖片的裁剪方式，縮放方式，旋轉角度等。

RequestCreator對外提供了一系列設置函數，返回的都是同一個RequestCreator對象，標準的構造者模式。完成所有設置後，調用into函數實現Request對象的最終構造。

這個函數是個很關鍵的函數，我們可以將它作爲理解Picasso加載過程的一條主線。該函數首先通過checkMain檢查是不是在主線程發起調用，由於加載圖片需要對UI進行操作，所以必須在主線程進行函數的調用。

checkMain的實現是通過比較當前線程和MainLooper線程是否是同一個線程進行的。

完成主線程檢查後，判斷有沒有設置圖片來源，包括Uri或ResourceID等，如果沒設置不進行加載。

接下來判斷可以立即加載，還是需要延遲加載。延遲加載的場景是使用fit()方法進行圖片尺寸自適應調整的時候。如果設置圖片根據需要展示的View的尺寸進行自動調整，而且這個View的寬度或高度設置爲0（比如通過weight進行相對寬高的設置），那麼代碼執行到這裏的時候View可能還沒完成測量的過程，還沒有計算出實際的寬高，就需要等測量完成後才進行加載，也就是延遲加載，這裏作爲into函數三個分支的第一個分支。

DeferredRequestCreator實現延遲加載，是通過給目標View註冊onAttachStateChangeListener監聽器實現的，監聽器的兩個接口函數onViewAttachedToWindow，onViewDetachedFromWindow分別對應了一個View被放置到界面上，和從界面上收回兩個時間節點。在onViewAttachedToWindow中，給view的ViewTreeObserver添加onPreDrawListener監聽器，並在onViewDetachedFromWindow中刪除該監聽器。onPreDrawListener監聽器的onPreDraw接口函數會在界面完成測量後將要被展示出來前調用，此時可以獲取到view的寬高，從而知道需要將加載的圖片縮放到的具體尺寸。獲取到具體尺寸後就可以通過unfit函數取消延遲加載的標識，通過resize設置尺寸，最後通過into函數生成最終的Request並提交到線程池去執行。

這是into函數裏面需要延遲執行的情形的處理。如果沒有通過fit進行自適應，而是一開始就指定了需要加載圖片的寬高，就走第二個分支的邏輯，嘗試從緩存獲取。

從createKey的實現可以看出，同一個來源的圖片，如果加載參數不同，會生成不同的key，並分別存儲到緩存中。接下來判斷是否設置了內存緩存，如果設置的話通過picasso.quickMemoryCacheCheck根據key查找緩存內容，找到的話返回這個bitmap，並設置給view。

可以看到，Cache是一個接口類，規範了一系列對緩存的操作接口，包括get/set/size/clear等，還包含一個空實現。Picasso提供了一個實現了Cache接口的類LruCache，用戶也可以提供自己的實現。

LruCache通過一個LinkedHashMap來存儲圖片鍵值對，LinkedHashMap結合了鏈表的FIFO特性以及HashMap的鍵值對存取特性，通過iterator遍歷的時候保證先加入的先遍歷到，當緩存的大小達到設定值的時候，通過trimToSize函數進行緩存的換出，藉助LinkedHashMap實現FIFO的換出策略。同時注意由於多個線程可以同時存取緩存，需要進行線程同步機制，這裏是通過synchronized加鎖實現的。

這裏一次圖片加載的操作是通過一個Action來表示的，Action是一個接口類，提供了跟一次圖片加載相關的操作，比如請求的Request，網絡緩存策略，內存緩存策略，加載成功的回調函數，失敗的回調，取消的回調等。

Picasso提供了幾種Action的實現，包括ImageViewAction（圖片加載並展示到ImageView），NotificationAction（圖片加載並展示到Notification），GetAction（圖片同步加載不展示），FetchAction（圖片異步加載並設置回調函數）等，下面給出ImageViewAction的代碼：

可以看到performSubmit函數會根據每個Action創建一個BitmapHunter對象，並通過ExecutorService提交到線程池執行。BitmapHunter是一個多線程類，提供了加載圖片的操作：

再次嘗試從內存緩存獲取，之前沒在內存緩存中，說不定這時候已經在了。如果獲取不到，調用RequestHandler的load函數進行真正的加載操作。

RequestHandler是個虛基類，提供了統一的加載接口：

NetworkRequestHandler，ContactsPhotoRequestHandler，AssetRequestHandler，ContentStreamRequestHandler,ResourceRequestHandler等都實現了RequestHandler基類，分別提供了網絡加載，聯繫人圖片加載，Asset資源加載，文件加載，Resource資源圖片加載等不同的加載方式。

這樣，就完成了Picasso加載圖片的整個流程分析。代碼量適中，結構也比較清晰，適合閱讀學習。