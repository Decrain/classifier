隨着蘋果對iOS系統多年的研發，iOS上的安全防護機制也是越來越多，越來越複雜。這對於剛接觸iOS安全的研究人員來說非常不友好，往往不知從何入手。因此，爲了讓大家能夠更加系統性的瞭解iOS上的安全機制，我們從三個方面着眼：代碼簽名(CodeSign)、沙盒機制(SandBox)和利用緩解(ExploitMitigation)，對iOS的系統安全機制做了一個總結。希望能夠給大家的學習以及研究帶來一定的幫助。注意，以下內容是以iOS9.3.4做爲標準進行講解。

爲了保護開發者的版權以及防止盜版應用，蘋果系統擁有非常嚴格的簽名保護機制。想要開發iOS程序，必須先註冊開發者賬號，並向蘋果申請相關的證書，否則程序只能在模擬器上運行，無法在真機上調試，也無法上架AppStore。除了傳統的簽名機制以外，蘋果還額外增加了TeamID的安全防護措施，用來增強iOS系統的安全性。

傳統的簽名機制即iOS系統中使用的數字證書機制。數字證書是一種對數字內容進行校驗的方法，它首先對內容使用摘要算法（例如MD5，SHA1）生成一段固定長度的hash值(可以理解爲原內容的摘要)，然後利用私鑰對這個摘要進行加密，得到原內容的數字簽名。接受方一併接收到原內容和數字簽名，首先用相同的摘要算法生成原內容的摘要，同時用公鑰解密數字簽名，得到摘要2，然後比較摘要1和摘要2，若相同，則驗證原內容有效。我們從蘋果MC（MemberCenter）中獲得的數字證書就是被蘋果CA簽過名的合法的證書。而iOS設備在執行app前，首先要先驗證CA的簽名是否合法，然後再通過證書中我們的公鑰來驗證app是否的確是開發者發佈的，且中途沒有對程序進行過篡改。理論上想要破解或者繞過這個簽名機制，需要能夠獲取到蘋果的私鑰，或者能夠找到簽名校驗過程中的漏洞。

iOS在運行代碼前，都會對即將運行的代碼進行簽名校驗。簽名的校驗機制是運行在內核裏的。因此想要關閉這個校驗的話，需要對系統進行越獄才行。內核在vm_fault_enter中規定了絕大部分情況下，具有執行位的頁需要進行簽名有效性檢查，如果檢查到該頁簽名無效會爲進程設置killflag。簽名校驗分兩種情況；如果binary是platformbinary，系統會直接校驗binary的哈希值是否存在於trustcache中。如果binary是第三方應用程序，會先在內核在檢查執行頁對應hash值，而頁hash對應的簽名由用戶態進程amfid校驗其正確性。

TeamID最早在iOS8中被提出，在iOS9中得到了進一步的加強。TeamID的出現主要是爲了阻止攻擊者將自己的動態庫加載到不屬於自己的executable中，常見例子：越獄過程中將動態庫加載到系統進程，獲得沙箱外的任意代碼執行能力；惡意應用通過沙箱逃逸將自己的動態庫加載到別人的app運行環境，盜取賬號密碼等有價值的信息。所以TeamID的具體的校驗邏輯就是根據這個原則來設計。除了特殊情況，系統的進程只能加載系統的動態庫。第三方app根據自己的TeamID來決定哪些具有相同TeamID的dylib能被加載。

很多系統都有沙盒機制，但是像iOS這麼複雜的卻很少。iOS從UID/GIDpermission，MAC和entitlement三個維度實現了整個系統的沙盒機制：

一般情況下，iOS會將進程的權限分爲root和mobile，一些特殊的模塊（比如基帶）會有自己的用戶組。需要注意的是，所有第三方的app都是運行在mobile權限下的。

iOS的MAC在TrustedBSDMacFramework基礎上實現，在內核具體接口、具體位置插入權限hookcheck（mac_**call），在發生調用時檢查當前進程是否滿足調用的MACpolice。

而進程的MACpolice主要是通過sandboxprofile。Sandboxprofile是蘋果爲每個系統進程或app預設的，例如：哪些文件可讀可寫，哪些不能；哪些systemcall可以調用，哪些不能等等。

對於系統進程，一般情況下蘋果會爲不同的系統進程配備不同的sandboxprofile，既滿足業務需求，又遵循權限最小化原則。

對於第三方app，則是統一配備名爲Container的sandboxprofile，這個profile裏面的內容限制可達數千條。限制非常嚴格，以致於只有很少數的syscall能在第三方app內訪問。一些安卓中非常普通的調用，例如fork，exec等創建子進程的系統調用，在第三方app內都是無法生效的。我們常說的沙盒逃逸，其實目的就是跳出container的sandboxprofile。

進程A提供的服務接口分別有：a1,a2，其中只希望接口a1能被B訪問。

因爲檢查發生在用戶態，不能直接使用TrustedBSDMacFramework，同時需要有更簡單的查詢方式，這樣就需要在a2接口的代碼中加入權限校驗。基於entitlement的校驗框架就是在這個需求背景下被提出來的。業務進程只需要關注entitlement的內容，而entitlement的正確性由簽名保證。比如想要訪問提供了能刪除app的接口的」com.apple.mobile.installd」服務就必須擁有對應的」com.apple.private.mobileinstall.allowedSPI」entitlement才行。而lockdownd這個service是用於和iTunes交互來進行安裝、升級、刪除應用的，所以這個服務爲了能與installd服務通訊，進行刪除app操作，就需要擁有」com.apple.private.mobileinstall.allowedSPI」這個entitlement：

除了常見的StackCanaries、ASLR和DEP等利用緩解技術之外，iOS還有很多高級的或者獨有的利用緩解技術：

棧金絲雀保護是已知的放置在緩衝器和控制數據之間的一個隨機值。當緩衝器溢出時，最先被破壞通常是金絲雀值。因此當金絲雀的數據的驗證失敗的時候，就表示出現了緩衝區溢出，從而觸發保護機制，並使程序停止運行。

爲了增加攻擊者預測目的地址的難度，防止攻擊者直接定位攻擊代碼位置，用戶態進程在每次啓動時的執行文件基址都是隨機生成的。並且，在每次手機重啓後，內核kernelmach-o的基址也是隨機的。

DEP是爲了防止數據頁執行代碼。通常情況下，默認不從堆和棧執行代碼。DEP會檢測從這些位置運行的代碼，並在發現執行情況時引發異常。在mprotect對應的內核實現中，不允許page被同時賦予執行和寫這兩種權限。當page的權限發生變化或一個新的pagemmap到內存中的時候，vm_fault_enter會檢查這個頁是否有執行位，如果有執行位，會對這個頁做簽名檢查。

在iOS中，如果修改一個zone中已釋放的freeelement，當內存管理器再次分配內存到這個freeelement的時候會發生隨機panic。具體的邏輯是，當element被釋放後，內核會根據重啓時創建的token生成一些內容填充在element中。這樣一方面用戶態無法得知填充的內容是什麼，另一方面內核在分配內存的時候可以根據token知道這個element有沒有被修改，如果被修改就產生panic。

iOS系統在釋放內存塊的過程中，會對內存釋放後在free隊列中的順序進行隨機化處理，這個安全措施主要是使用攻擊者無法根據堆噴接口調用的時序來預測對應元素在內核的佈局。

ARMv8-A架構定義了四個例外層級，分別爲EL0到EL3，其中數字越大代表特權(privilege)越大:

KPP就是運行在ApplicationProcess的EL3中，目的是用來保證：只讀的頁不可修改、pagetable不可修改、執行頁不可修改。

雖然iOS有衆多的安全機制和緩解措施，但這並不代表iOS系統牢不可破。有時候一些不起眼的小錯誤就可能導致蝴蝶效應，最終造成整個安全系統的崩盤。